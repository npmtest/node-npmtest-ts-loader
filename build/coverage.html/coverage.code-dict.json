{"/home/travis/build/npmtest/node-npmtest-ts-loader/test.js":"/* istanbul instrument in package npmtest_ts_loader */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ts-loader/lib.npmtest_ts_loader.js":"/* istanbul instrument in package npmtest_ts_loader */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ts_loader = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ts_loader = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ts-loader/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ts-loader && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ts_loader */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ts_loader\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ts_loader.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ts_loader.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ts_loader.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ts_loader.__dirname + '/lib.npmtest_ts_loader.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ts-loader/node_modules/ts-loader/index.js":"var loader = require('./dist');\n\nmodule.exports = loader;","/home/travis/build/npmtest/node-npmtest-ts-loader/node_modules/ts-loader/dist/index.js":"\"use strict\";\r\nvar path = require(\"path\");\r\nvar loaderUtils = require(\"loader-utils\");\r\nrequire('colors');\r\nvar instances = require(\"./instances\");\r\nvar utils = require(\"./utils\");\r\nvar constants = require(\"./constants\");\r\nvar webpackInstances = [];\r\nvar loaderOptionsCache = {};\r\n/**\r\n * The entry point for ts-loader\r\n */\r\nfunction loader(contents) {\r\n    this.cacheable && this.cacheable();\r\n    var callback = this.async();\r\n    var options = getLoaderOptions(this);\r\n    var _a = instances.getTypeScriptInstance(options, this), instance = _a.instance, error = _a.error;\r\n    if (error) {\r\n        callback(error);\r\n        return;\r\n    }\r\n    var rawFilePath = path.normalize(this.resourcePath);\r\n    var filePath = utils.appendTsSuffixIfMatch(options.appendTsSuffixTo, rawFilePath);\r\n    var fileVersion = updateFileInCache(filePath, contents, instance);\r\n    var _b = options.transpileOnly\r\n        ? getTranspilationEmit(filePath, contents, instance, this)\r\n        : getEmit(rawFilePath, filePath, instance, this), outputText = _b.outputText, sourceMapText = _b.sourceMapText;\r\n    if (outputText === null || outputText === undefined) {\r\n        var additionalGuidance = filePath.indexOf('node_modules') !== -1\r\n            ? \"\\nYou should not need to recompile .ts files in node_modules.\\nPlease contact the package author to advise them to use --declaration --outDir.\\nMore https://github.com/Microsoft/TypeScript/issues/12358\"\r\n            : \"\";\r\n        throw new Error(\"Typescript emitted no output for \" + filePath + \".\" + additionalGuidance);\r\n    }\r\n    var _c = makeSourceMap(sourceMapText, outputText, filePath, contents, this), sourceMap = _c.sourceMap, output = _c.output;\r\n    // Make sure webpack is aware that even though the emitted JavaScript may be the same as\r\n    // a previously cached version the TypeScript may be different and therefore should be\r\n    // treated as new\r\n    this._module.meta.tsLoaderFileVersion = fileVersion;\r\n    callback(null, output, sourceMap);\r\n}\r\n/**\r\n * either retrieves loader options from the cache\r\n * or creates them, adds them to the cache and returns\r\n */\r\nfunction getLoaderOptions(loader) {\r\n    // differentiate the TypeScript instance based on the webpack instance\r\n    var webpackIndex = webpackInstances.indexOf(loader._compiler);\r\n    if (webpackIndex === -1) {\r\n        webpackIndex = webpackInstances.push(loader._compiler) - 1;\r\n    }\r\n    var queryOptions = loaderUtils.getOptions(loader) || {};\r\n    var configFileOptions = loader.options.ts || {};\r\n    var instanceName = webpackIndex + '_' + (queryOptions.instance || configFileOptions.instance || 'default');\r\n    if (utils.hasOwnProperty(loaderOptionsCache, instanceName)) {\r\n        return loaderOptionsCache[instanceName];\r\n    }\r\n    var options = Object.assign({}, {\r\n        silent: false,\r\n        logLevel: 'INFO',\r\n        logInfoToStdOut: false,\r\n        compiler: 'typescript',\r\n        configFileName: 'tsconfig.json',\r\n        transpileOnly: false,\r\n        visualStudioErrorFormat: false,\r\n        compilerOptions: {},\r\n        appendTsSuffixTo: [],\r\n        entryFileIsJs: false,\r\n    }, configFileOptions, queryOptions);\r\n    options.ignoreDiagnostics = utils.arrify(options.ignoreDiagnostics).map(Number);\r\n    options.logLevel = options.logLevel.toUpperCase();\r\n    options.instance = instanceName;\r\n    loaderOptionsCache[instanceName] = options;\r\n    return options;\r\n}\r\n/**\r\n * Either add file to the overall files cache or update it in the cache when the file contents have changed\r\n * Also add the file to the modified files\r\n */\r\nfunction updateFileInCache(filePath, contents, instance) {\r\n    // Update file contents\r\n    var file = instance.files[filePath];\r\n    if (!file) {\r\n        file = instance.files[filePath] = { version: 0 };\r\n    }\r\n    if (file.text !== contents) {\r\n        file.version++;\r\n        file.text = contents;\r\n        instance.version++;\r\n    }\r\n    // push this file to modified files hash.\r\n    if (!instance.modifiedFiles) {\r\n        instance.modifiedFiles = {};\r\n    }\r\n    instance.modifiedFiles[filePath] = file;\r\n    return file.version;\r\n}\r\nfunction getEmit(rawFilePath, filePath, instance, loader) {\r\n    // Emit Javascript\r\n    var output = instance.languageService.getEmitOutput(filePath);\r\n    loader.clearDependencies();\r\n    loader.addDependency(rawFilePath);\r\n    var allDefinitionFiles = Object.keys(instance.files).filter(function (defFilePath) { return !!defFilePath.match(constants.dtsDtsxRegex); });\r\n    // Make this file dependent on *all* definition files in the program\r\n    var addDependency = loader.addDependency.bind(loader);\r\n    allDefinitionFiles.forEach(addDependency);\r\n    /* - alternative approach to the below which is more correct but has a heavy performance cost\r\n         see https://github.com/TypeStrong/ts-loader/issues/393\r\n         with this approach constEnumReExportWatch test will pass; without it, not.\r\n\r\n    // Additionally make this file dependent on all imported files as well\r\n    // as any deeper recursive dependencies\r\n    const additionalDependencies = utils.collectAllDependencies(instance.dependencyGraph, filePath);\r\n    */\r\n    // Additionally make this file dependent on all imported files\r\n    var additionalDependencies = instance.dependencyGraph[filePath]\r\n        && instance.dependencyGraph[filePath].map(function (module) { return module.originalFileName; });\r\n    if (additionalDependencies) {\r\n        additionalDependencies.forEach(addDependency);\r\n    }\r\n    loader._module.meta.tsLoaderDefinitionFileVersions = allDefinitionFiles\r\n        .concat(additionalDependencies)\r\n        .map(function (defFilePath) { return defFilePath + '@' + (instance.files[defFilePath] || { version: '?' }).version; });\r\n    var outputFile = output.outputFiles.filter(function (outputFile) { return !!outputFile.name.match(constants.jsJsx); }).pop();\r\n    var outputText = (outputFile) ? outputFile.text : undefined;\r\n    var sourceMapFile = output.outputFiles.filter(function (outputFile) { return !!outputFile.name.match(constants.jsJsxMap); }).pop();\r\n    var sourceMapText = (sourceMapFile) ? sourceMapFile.text : undefined;\r\n    return { outputText: outputText, sourceMapText: sourceMapText };\r\n}\r\n/**\r\n * Transpile file\r\n */\r\nfunction getTranspilationEmit(filePath, contents, instance, loader) {\r\n    var fileName = path.basename(filePath);\r\n    var _a = instance.compiler.transpileModule(contents, {\r\n        compilerOptions: instance.compilerOptions,\r\n        reportDiagnostics: true,\r\n        fileName: fileName,\r\n    }), outputText = _a.outputText, sourceMapText = _a.sourceMapText, diagnostics = _a.diagnostics;\r\n    utils.registerWebpackErrors(loader._module.errors, utils.formatErrors(diagnostics, instance.loaderOptions, instance.compiler, { module: loader._module }));\r\n    return { outputText: outputText, sourceMapText: sourceMapText };\r\n}\r\nfunction makeSourceMap(sourceMapText, outputText, filePath, contents, loader) {\r\n    if (!sourceMapText) {\r\n        return { output: outputText, sourceMap: undefined };\r\n    }\r\n    return {\r\n        output: outputText.replace(/^\\/\\/# sourceMappingURL=[^\\r\\n]*/gm, ''),\r\n        sourceMap: Object.assign(JSON.parse(sourceMapText), {\r\n            sources: [loaderUtils.getRemainingRequest(loader)],\r\n            file: filePath,\r\n            sourcesContent: [contents]\r\n        })\r\n    };\r\n}\r\nmodule.exports = loader;\r\n","/home/travis/build/npmtest/node-npmtest-ts-loader/node_modules/ts-loader/dist/instances.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar path = require(\"path\");\r\nvar fs = require(\"fs\");\r\nrequire('colors');\r\nvar afterCompile = require(\"./after-compile\");\r\nvar config = require(\"./config\");\r\nvar compilerSetup = require(\"./compilerSetup\");\r\nvar utils = require(\"./utils\");\r\nvar logger = require(\"./logger\");\r\nvar makeServicesHost = require(\"./servicesHost\");\r\nvar watchRun = require(\"./watch-run\");\r\nvar instances = {};\r\n/**\r\n * The loader is executed once for each file seen by webpack. However, we need to keep\r\n * a persistent instance of TypeScript that contains all of the files in the program\r\n * along with definition files and options. This function either creates an instance\r\n * or returns the existing one. Multiple instances are possible by using the\r\n * `instance` property.\r\n */\r\nfunction getTypeScriptInstance(loaderOptions, loader) {\r\n    if (utils.hasOwnProperty(instances, loaderOptions.instance)) {\r\n        return { instance: instances[loaderOptions.instance] };\r\n    }\r\n    var log = logger.makeLogger(loaderOptions);\r\n    var _a = compilerSetup.getCompiler(loaderOptions, log), compiler = _a.compiler, compilerCompatible = _a.compilerCompatible, compilerDetailsLogMessage = _a.compilerDetailsLogMessage, errorMessage = _a.errorMessage;\r\n    if (errorMessage) {\r\n        return { error: utils.makeError({ rawMessage: errorMessage }) };\r\n    }\r\n    var _b = config.getConfigFile(compiler, loader, loaderOptions, compilerCompatible, log, compilerDetailsLogMessage), configFilePath = _b.configFilePath, configFile = _b.configFile, configFileError = _b.configFileError;\r\n    if (configFileError) {\r\n        return { error: configFileError };\r\n    }\r\n    var configParseResult = config.getConfigParseResult(compiler, configFile, configFilePath);\r\n    if (configParseResult.errors.length) {\r\n        utils.registerWebpackErrors(loader._module.errors, utils.formatErrors(configParseResult.errors, loaderOptions, compiler, { file: configFilePath }));\r\n        return { error: utils.makeError({ rawMessage: 'error while parsing tsconfig.json', file: configFilePath }) };\r\n    }\r\n    var compilerOptions = compilerSetup.getCompilerOptions(compilerCompatible, compiler, configParseResult);\r\n    var files = {};\r\n    if (loaderOptions.transpileOnly) {\r\n        // quick return for transpiling\r\n        // we do need to check for any issues with TS options though\r\n        var program = compiler.createProgram([], compilerOptions);\r\n        var diagnostics = program.getOptionsDiagnostics();\r\n        utils.registerWebpackErrors(loader._module.errors, utils.formatErrors(diagnostics, loaderOptions, compiler, { file: configFilePath || 'tsconfig.json' }));\r\n        return { instance: instances[loaderOptions.instance] = { compiler: compiler, compilerOptions: compilerOptions, loaderOptions: loaderOptions, files: files, dependencyGraph: {}, reverseDependencyGraph: {} } };\r\n    }\r\n    // Load initial files (core lib files, any files specified in tsconfig.json)\r\n    var normalizedFilePath;\r\n    try {\r\n        var filesToLoad = configParseResult.fileNames;\r\n        filesToLoad.forEach(function (filePath) {\r\n            normalizedFilePath = path.normalize(filePath);\r\n            files[normalizedFilePath] = {\r\n                text: fs.readFileSync(normalizedFilePath, 'utf-8'),\r\n                version: 0\r\n            };\r\n        });\r\n    }\r\n    catch (exc) {\r\n        return { error: utils.makeError({\r\n                rawMessage: \"A file specified in tsconfig.json could not be found: \" + normalizedFilePath\r\n            }) };\r\n    }\r\n    // if allowJs is set then we should accept js(x) files\r\n    var scriptRegex = configParseResult.options.allowJs && loaderOptions.entryFileIsJs\r\n        ? /\\.tsx?$|\\.jsx?$/i\r\n        : /\\.tsx?$/i;\r\n    var instance = instances[loaderOptions.instance] = {\r\n        compiler: compiler,\r\n        compilerOptions: compilerOptions,\r\n        loaderOptions: loaderOptions,\r\n        files: files,\r\n        languageService: null,\r\n        version: 0,\r\n        dependencyGraph: {},\r\n        reverseDependencyGraph: {},\r\n        modifiedFiles: null,\r\n    };\r\n    var servicesHost = makeServicesHost(scriptRegex, log, loader, instance, loaderOptions.appendTsSuffixTo);\r\n    instance.languageService = compiler.createLanguageService(servicesHost, compiler.createDocumentRegistry());\r\n    loader._compiler.plugin(\"after-compile\", afterCompile(instance, configFilePath));\r\n    loader._compiler.plugin(\"watch-run\", watchRun(instance));\r\n    return { instance: instance };\r\n}\r\nexports.getTypeScriptInstance = getTypeScriptInstance;\r\n","/home/travis/build/npmtest/node-npmtest-ts-loader/node_modules/ts-loader/dist/after-compile.js":"\"use strict\";\r\nvar path = require(\"path\");\r\nvar utils = require(\"./utils\");\r\nvar constants = require(\"./constants\");\r\nfunction makeAfterCompile(instance, configFilePath) {\r\n    var getCompilerOptionDiagnostics = true;\r\n    var checkAllFilesForErrors = true;\r\n    return function (compilation, callback) {\r\n        // Don't add errors for child compilations\r\n        if (compilation.compiler.isChild()) {\r\n            callback();\r\n            return;\r\n        }\r\n        removeTSLoaderErrors(compilation.errors);\r\n        provideCompilerOptionDiagnosticErrorsToWebpack(getCompilerOptionDiagnostics, compilation, instance, configFilePath);\r\n        getCompilerOptionDiagnostics = false;\r\n        var modules = determineModules(compilation);\r\n        var filesToCheckForErrors = determineFilesToCheckForErrors(checkAllFilesForErrors, instance);\r\n        checkAllFilesForErrors = false;\r\n        var filesWithErrors = {};\r\n        provideErrorsToWebpack(filesToCheckForErrors, filesWithErrors, compilation, modules, instance);\r\n        provideDeclarationFilesToWebpack(filesToCheckForErrors, instance.languageService, compilation);\r\n        instance.filesWithErrors = filesWithErrors;\r\n        instance.modifiedFiles = null;\r\n        callback();\r\n    };\r\n}\r\n/**\r\n * handle compiler option errors after the first compile\r\n */\r\nfunction provideCompilerOptionDiagnosticErrorsToWebpack(getCompilerOptionDiagnostics, compilation, instance, configFilePath) {\r\n    if (getCompilerOptionDiagnostics) {\r\n        var languageService = instance.languageService, loaderOptions = instance.loaderOptions, compiler = instance.compiler;\r\n        utils.registerWebpackErrors(compilation.errors, utils.formatErrors(languageService.getCompilerOptionsDiagnostics(), loaderOptions, compiler, { file: configFilePath || 'tsconfig.json' }));\r\n    }\r\n}\r\n/**\r\n * build map of all modules based on normalized filename\r\n * this is used for quick-lookup when trying to find modules\r\n * based on filepath\r\n */\r\nfunction determineModules(compilation) {\r\n    var modules = {};\r\n    compilation.modules.forEach(function (module) {\r\n        if (module.resource) {\r\n            var modulePath = path.normalize(module.resource);\r\n            if (utils.hasOwnProperty(modules, modulePath)) {\r\n                var existingModules = modules[modulePath];\r\n                if (existingModules.indexOf(module) === -1) {\r\n                    existingModules.push(module);\r\n                }\r\n            }\r\n            else {\r\n                modules[modulePath] = [module];\r\n            }\r\n        }\r\n    });\r\n    return modules;\r\n}\r\nfunction determineFilesToCheckForErrors(checkAllFilesForErrors, instance) {\r\n    var files = instance.files, modifiedFiles = instance.modifiedFiles, filesWithErrors = instance.filesWithErrors;\r\n    // calculate array of files to check\r\n    var filesToCheckForErrors = {};\r\n    if (checkAllFilesForErrors) {\r\n        // check all files on initial run\r\n        filesToCheckForErrors = files;\r\n    }\r\n    else if (modifiedFiles) {\r\n        // check all modified files, and all dependants\r\n        Object.keys(modifiedFiles).forEach(function (modifiedFileName) {\r\n            utils.collectAllDependants(instance.reverseDependencyGraph, modifiedFileName)\r\n                .forEach(function (fileName) {\r\n                filesToCheckForErrors[fileName] = files[fileName];\r\n            });\r\n        });\r\n    }\r\n    // re-check files with errors from previous build\r\n    if (filesWithErrors) {\r\n        Object.keys(filesWithErrors).forEach(function (fileWithErrorName) {\r\n            return filesToCheckForErrors[fileWithErrorName] = filesWithErrors[fileWithErrorName];\r\n        });\r\n    }\r\n    return filesToCheckForErrors;\r\n}\r\nfunction provideErrorsToWebpack(filesToCheckForErrors, filesWithErrors, compilation, modules, instance) {\r\n    var compiler = instance.compiler, languageService = instance.languageService, files = instance.files, loaderOptions = instance.loaderOptions;\r\n    Object.keys(filesToCheckForErrors)\r\n        .filter(function (filePath) { return !!filePath.match(constants.dtsTsTsxRegex); })\r\n        .forEach(function (filePath) {\r\n        var errors = languageService.getSyntacticDiagnostics(filePath).concat(languageService.getSemanticDiagnostics(filePath));\r\n        if (errors.length > 0) {\r\n            filesWithErrors[filePath] = files[filePath];\r\n        }\r\n        // if we have access to a webpack module, use that\r\n        if (utils.hasOwnProperty(modules, filePath)) {\r\n            var associatedModules = modules[filePath];\r\n            associatedModules.forEach(function (module) {\r\n                // remove any existing errors\r\n                removeTSLoaderErrors(module.errors);\r\n                // append errors\r\n                var formattedErrors = utils.formatErrors(errors, loaderOptions, compiler, { module: module });\r\n                utils.registerWebpackErrors(module.errors, formattedErrors);\r\n                utils.registerWebpackErrors(compilation.errors, formattedErrors);\r\n            });\r\n        }\r\n        else {\r\n            // otherwise it's a more generic error\r\n            utils.registerWebpackErrors(compilation.errors, utils.formatErrors(errors, loaderOptions, compiler, { file: filePath }));\r\n        }\r\n    });\r\n}\r\n/**\r\n * gather all declaration files from TypeScript and output them to webpack\r\n */\r\nfunction provideDeclarationFilesToWebpack(filesToCheckForErrors, languageService, compilation) {\r\n    Object.keys(filesToCheckForErrors)\r\n        .filter(function (filePath) { return !!filePath.match(constants.tsTsxRegex); })\r\n        .forEach(function (filePath) {\r\n        var output = languageService.getEmitOutput(filePath);\r\n        var declarationFile = output.outputFiles.filter(function (outputFile) { return !!outputFile.name.match(constants.dtsDtsxRegex); }).pop();\r\n        if (declarationFile) {\r\n            var assetPath = path.relative(compilation.compiler.context, declarationFile.name);\r\n            compilation.assets[assetPath] = {\r\n                source: function () { return declarationFile.text; },\r\n                size: function () { return declarationFile.text.length; },\r\n            };\r\n        }\r\n    });\r\n}\r\n/**\r\n * handle all other errors. The basic approach here to get accurate error\r\n * reporting is to start with a \"blank slate\" each compilation and gather\r\n * all errors from all files. Since webpack tracks errors in a module from\r\n * compilation-to-compilation, and since not every module always runs through\r\n * the loader, we need to detect and remove any pre-existing errors.\r\n */\r\nfunction removeTSLoaderErrors(errors) {\r\n    var index = -1;\r\n    var length = errors.length;\r\n    while (++index < length) {\r\n        if (errors[index].loaderSource === 'ts-loader') {\r\n            errors.splice(index--, 1);\r\n            length--;\r\n        }\r\n    }\r\n}\r\nmodule.exports = makeAfterCompile;\r\n","/home/travis/build/npmtest/node-npmtest-ts-loader/node_modules/ts-loader/dist/utils.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar path = require(\"path\");\r\nvar fs = require(\"fs\");\r\nvar constants = require(\"./constants\");\r\nfunction registerWebpackErrors(existingErrors, errorsToPush) {\r\n    Array.prototype.splice.apply(existingErrors, [0, 0].concat(errorsToPush));\r\n}\r\nexports.registerWebpackErrors = registerWebpackErrors;\r\nfunction hasOwnProperty(obj, property) {\r\n    return Object.prototype.hasOwnProperty.call(obj, property);\r\n}\r\nexports.hasOwnProperty = hasOwnProperty;\r\n/**\r\n * Take TypeScript errors, parse them and format to webpack errors\r\n * Optionally adds a file name\r\n */\r\nfunction formatErrors(diagnostics, loaderOptions, compiler, merge) {\r\n    return diagnostics\r\n        .filter(function (diagnostic) { return loaderOptions.ignoreDiagnostics.indexOf(diagnostic.code) === -1; })\r\n        .map(function (diagnostic) {\r\n        var errorCategory = compiler.DiagnosticCategory[diagnostic.category].toLowerCase();\r\n        var errorCategoryAndCode = errorCategory + ' TS' + diagnostic.code + ': ';\r\n        var messageText = errorCategoryAndCode + compiler.flattenDiagnosticMessageText(diagnostic.messageText, constants.EOL);\r\n        var error;\r\n        if (diagnostic.file) {\r\n            var lineChar = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);\r\n            var errorMessage = \"\" + '('.white + (lineChar.line + 1).toString().cyan + \",\" + (lineChar.character + 1).toString().cyan + \"): \" + messageText.red;\r\n            if (loaderOptions.visualStudioErrorFormat) {\r\n                errorMessage = path.normalize(diagnostic.file.fileName).red + errorMessage;\r\n            }\r\n            error = makeError({\r\n                message: errorMessage,\r\n                rawMessage: messageText,\r\n                location: { line: lineChar.line + 1, character: lineChar.character + 1 }\r\n            });\r\n        }\r\n        else {\r\n            error = makeError({ rawMessage: messageText });\r\n        }\r\n        return Object.assign(error, merge);\r\n    });\r\n}\r\nexports.formatErrors = formatErrors;\r\nfunction readFile(fileName) {\r\n    fileName = path.normalize(fileName);\r\n    try {\r\n        return fs.readFileSync(fileName, 'utf8');\r\n    }\r\n    catch (e) {\r\n        return undefined;\r\n    }\r\n}\r\nexports.readFile = readFile;\r\nfunction makeError(_a) {\r\n    var rawMessage = _a.rawMessage, message = _a.message, location = _a.location, file = _a.file;\r\n    var error = {\r\n        rawMessage: rawMessage,\r\n        message: message || \"\" + rawMessage.red,\r\n        loaderSource: 'ts-loader'\r\n    };\r\n    return Object.assign(error, { location: location, file: file });\r\n}\r\nexports.makeError = makeError;\r\nfunction appendTsSuffixIfMatch(patterns, path) {\r\n    if (patterns.length > 0) {\r\n        for (var _i = 0, patterns_1 = patterns; _i < patterns_1.length; _i++) {\r\n            var regexp = patterns_1[_i];\r\n            if (path.match(regexp)) {\r\n                return path + '.ts';\r\n            }\r\n        }\r\n    }\r\n    return path;\r\n}\r\nexports.appendTsSuffixIfMatch = appendTsSuffixIfMatch;\r\n/**\r\n * Recursively collect all possible dependants of passed file\r\n */\r\nfunction collectAllDependants(reverseDependencyGraph, fileName, collected) {\r\n    if (collected === void 0) { collected = {}; }\r\n    var result = {};\r\n    result[fileName] = true;\r\n    collected[fileName] = true;\r\n    if (reverseDependencyGraph[fileName]) {\r\n        Object.keys(reverseDependencyGraph[fileName]).forEach(function (dependantFileName) {\r\n            if (!collected[dependantFileName]) {\r\n                collectAllDependants(reverseDependencyGraph, dependantFileName, collected)\r\n                    .forEach(function (fName) { return result[fName] = true; });\r\n            }\r\n        });\r\n    }\r\n    return Object.keys(result);\r\n}\r\nexports.collectAllDependants = collectAllDependants;\r\n/**\r\n * Recursively collect all possible dependencies of passed file\r\n */\r\nfunction collectAllDependencies(dependencyGraph, filePath, collected) {\r\n    if (collected === void 0) { collected = {}; }\r\n    var result = {};\r\n    result[filePath] = true;\r\n    collected[filePath] = true;\r\n    var directDependencies = dependencyGraph[filePath];\r\n    if (directDependencies) {\r\n        directDependencies.forEach(function (dependencyModule) {\r\n            if (!collected[dependencyModule.originalFileName]) {\r\n                collectAllDependencies(dependencyGraph, dependencyModule.resolvedFileName, collected)\r\n                    .forEach(function (filePath) { return result[filePath] = true; });\r\n            }\r\n        });\r\n    }\r\n    return Object.keys(result);\r\n}\r\nexports.collectAllDependencies = collectAllDependencies;\r\nfunction arrify(val) {\r\n    if (val === null || val === undefined) {\r\n        return [];\r\n    }\r\n    return Array.isArray(val) ? val : [val];\r\n}\r\nexports.arrify = arrify;\r\n;\r\n","/home/travis/build/npmtest/node-npmtest-ts-loader/node_modules/ts-loader/dist/constants.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar os = require(\"os\");\r\nexports.EOL = os.EOL;\r\nexports.CarriageReturnLineFeed = '\\r\\n';\r\nexports.LineFeed = '\\n';\r\nexports.CarriageReturnLineFeedCode = 0;\r\nexports.LineFeedCode = 1;\r\nexports.ScriptTargetES2015 = 2;\r\nexports.ModuleKindNone = 0;\r\nexports.ModuleKindCommonJs = 1;\r\nexports.tsTsxRegex = /\\.ts(x?)$/i;\r\nexports.dtsDtsxRegex = /\\.d\\.ts(x?)$/i;\r\nexports.dtsTsTsxRegex = /(\\.d)?\\.ts(x?)$/i;\r\nexports.tsTsxJsJsxRegex = /\\.tsx?$|\\.jsx?$/i;\r\nexports.jsJsx = /\\.js(x?)$/i;\r\nexports.jsJsxMap = /\\.js(x?)\\.map$/i;\r\n","/home/travis/build/npmtest/node-npmtest-ts-loader/node_modules/ts-loader/dist/config.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar path = require(\"path\");\r\nvar utils = require(\"./utils\");\r\nfunction getConfigFile(compiler, loader, loaderOptions, compilerCompatible, log, compilerDetailsLogMessage) {\r\n    var configFilePath = findConfigFile(compiler, path.dirname(loader.resourcePath), loaderOptions.configFileName);\r\n    var configFileError;\r\n    var configFile;\r\n    if (configFilePath) {\r\n        if (compilerCompatible) {\r\n            log.logInfo((compilerDetailsLogMessage + \" and \" + configFilePath).green);\r\n        }\r\n        else {\r\n            log.logInfo((\"ts-loader: Using config file at \" + configFilePath).green);\r\n        }\r\n        // HACK: relies on the fact that passing an extra argument won't break\r\n        // the old API that has a single parameter\r\n        configFile = compiler.readConfigFile(configFilePath, compiler.sys.readFile);\r\n        if (configFile.error) {\r\n            configFileError = utils.formatErrors([configFile.error], loaderOptions, compiler, { file: configFilePath })[0];\r\n        }\r\n    }\r\n    else {\r\n        if (compilerCompatible) {\r\n            log.logInfo(compilerDetailsLogMessage.green);\r\n        }\r\n        configFile = {\r\n            config: {\r\n                compilerOptions: {},\r\n                files: [],\r\n            },\r\n        };\r\n    }\r\n    if (!configFileError) {\r\n        configFile.config.compilerOptions = Object.assign({}, configFile.config.compilerOptions, loaderOptions.compilerOptions);\r\n        // do any necessary config massaging\r\n        if (loaderOptions.transpileOnly) {\r\n            configFile.config.compilerOptions.isolatedModules = true;\r\n        }\r\n    }\r\n    return {\r\n        configFilePath: configFilePath,\r\n        configFile: configFile,\r\n        configFileError: configFileError\r\n    };\r\n}\r\nexports.getConfigFile = getConfigFile;\r\n/**\r\n * The tsconfig.json is found using the same method as `tsc`, starting in the current directory\r\n * and continuing up the parent directory chain.\r\n */\r\nfunction findConfigFile(compiler, searchPath, configFileName) {\r\n    while (true) {\r\n        var fileName = path.join(searchPath, configFileName);\r\n        if (compiler.sys.fileExists(fileName)) {\r\n            return fileName;\r\n        }\r\n        var parentPath = path.dirname(searchPath);\r\n        if (parentPath === searchPath) {\r\n            break;\r\n        }\r\n        searchPath = parentPath;\r\n    }\r\n    return undefined;\r\n}\r\nfunction getConfigParseResult(compiler, configFile, configFilePath) {\r\n    var configParseResult;\r\n    if (typeof compiler.parseJsonConfigFileContent === 'function') {\r\n        // parseConfigFile was renamed between 1.6.2 and 1.7\r\n        configParseResult = compiler.parseJsonConfigFileContent(configFile.config, compiler.sys, path.dirname(configFilePath || ''));\r\n    }\r\n    else {\r\n        configParseResult = compiler.parseConfigFile(configFile.config, compiler.sys, path.dirname(configFilePath || ''));\r\n    }\r\n    return configParseResult;\r\n}\r\nexports.getConfigParseResult = getConfigParseResult;\r\n","/home/travis/build/npmtest/node-npmtest-ts-loader/node_modules/ts-loader/dist/compilerSetup.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar semver = require('semver');\r\nvar constants = require(\"./constants\");\r\nfunction getCompiler(loaderOptions, log) {\r\n    var compiler;\r\n    var errorMessage;\r\n    var compilerDetailsLogMessage;\r\n    var compilerCompatible = false;\r\n    try {\r\n        compiler = require(loaderOptions.compiler);\r\n    }\r\n    catch (e) {\r\n        errorMessage = loaderOptions.compiler === 'typescript'\r\n            ? 'Could not load TypeScript. Try installing with `npm install typescript`. If TypeScript is installed globally, try using `npm link typescript`.'\r\n            : \"Could not load TypeScript compiler with NPM package name `\" + loaderOptions.compiler + \"`. Are you sure it is correctly installed?\";\r\n    }\r\n    if (!errorMessage) {\r\n        compilerDetailsLogMessage = \"ts-loader: Using \" + loaderOptions.compiler + \"@\" + compiler.version;\r\n        compilerCompatible = false;\r\n        if (loaderOptions.compiler === 'typescript') {\r\n            if (compiler.version && semver.gte(compiler.version, '1.6.2-0')) {\r\n                // don't log yet in this case, if a tsconfig.json exists we want to combine the message\r\n                compilerCompatible = true;\r\n            }\r\n            else {\r\n                log.logError((compilerDetailsLogMessage + \". This version is incompatible with ts-loader. Please upgrade to the latest version of TypeScript.\").red);\r\n            }\r\n        }\r\n        else {\r\n            log.logWarning((compilerDetailsLogMessage + \". This version may or may not be compatible with ts-loader.\").yellow);\r\n        }\r\n    }\r\n    return { compiler: compiler, compilerCompatible: compilerCompatible, compilerDetailsLogMessage: compilerDetailsLogMessage, errorMessage: errorMessage };\r\n}\r\nexports.getCompiler = getCompiler;\r\nfunction getCompilerOptions(compilerCompatible, compiler, configParseResult) {\r\n    var compilerOptions = Object.assign({}, configParseResult.options, {\r\n        skipDefaultLibCheck: true,\r\n        suppressOutputPathCheck: true,\r\n    });\r\n    // if `module` is not specified and not using ES6 target, default to CJS module output\r\n    if ((!compilerOptions.module) && compilerOptions.target !== constants.ScriptTargetES2015) {\r\n        compilerOptions.module = constants.ModuleKindCommonJs;\r\n    }\r\n    else if (compilerCompatible && semver.lt(compiler.version, '1.7.3-0') && compilerOptions.target === constants.ScriptTargetES2015) {\r\n        // special handling for TS 1.6 and target: es6\r\n        compilerOptions.module = constants.ModuleKindNone;\r\n    }\r\n    return compilerOptions;\r\n}\r\nexports.getCompilerOptions = getCompilerOptions;\r\n","/home/travis/build/npmtest/node-npmtest-ts-loader/node_modules/ts-loader/dist/logger.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Console = require('console').Console;\r\nvar stderrConsole = new Console(process.stderr);\r\nvar stdoutConsole = new Console(process.stdout);\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"INFO\"] = 1] = \"INFO\";\r\n    LogLevel[LogLevel[\"WARN\"] = 2] = \"WARN\";\r\n    LogLevel[LogLevel[\"ERROR\"] = 3] = \"ERROR\";\r\n})(LogLevel || (LogLevel = {}));\r\nvar doNothingLogger = function () {\r\n    var _messages = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        _messages[_i] = arguments[_i];\r\n    }\r\n};\r\nfunction makeLoggerFunc(loaderOptions) {\r\n    return loaderOptions.silent\r\n        ? function (_whereToLog, _messages) { }\r\n        : function (whereToLog, messages) { return console.log.apply(whereToLog, messages); };\r\n}\r\nfunction makeExternalLogger(loaderOptions, logger) {\r\n    var output = loaderOptions.logInfoToStdOut ? stdoutConsole : stderrConsole;\r\n    return function () {\r\n        var messages = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            messages[_i] = arguments[_i];\r\n        }\r\n        return logger(output, messages);\r\n    };\r\n}\r\nfunction makeLogInfo(loaderOptions, logger) {\r\n    return LogLevel[loaderOptions.logLevel] <= LogLevel.INFO\r\n        ? function () {\r\n            var messages = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                messages[_i] = arguments[_i];\r\n            }\r\n            return logger(loaderOptions.logInfoToStdOut ? stdoutConsole : stderrConsole, messages);\r\n        }\r\n        : doNothingLogger;\r\n}\r\nfunction makeLogError(loaderOptions, logger) {\r\n    return LogLevel[loaderOptions.logLevel] <= LogLevel.ERROR\r\n        ? function () {\r\n            var messages = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                messages[_i] = arguments[_i];\r\n            }\r\n            return logger(stderrConsole, messages);\r\n        }\r\n        : doNothingLogger;\r\n}\r\nfunction makeLogWarning(loaderOptions, logger) {\r\n    return LogLevel[loaderOptions.logLevel] <= LogLevel.WARN\r\n        ? function () {\r\n            var messages = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                messages[_i] = arguments[_i];\r\n            }\r\n            return logger(stderrConsole, messages);\r\n        }\r\n        : doNothingLogger;\r\n}\r\nfunction makeLogger(loaderOptions) {\r\n    var logger = makeLoggerFunc(loaderOptions);\r\n    return {\r\n        log: makeExternalLogger(loaderOptions, logger),\r\n        logInfo: makeLogInfo(loaderOptions, logger),\r\n        logWarning: makeLogWarning(loaderOptions, logger),\r\n        logError: makeLogError(loaderOptions, logger)\r\n    };\r\n}\r\nexports.makeLogger = makeLogger;\r\n","/home/travis/build/npmtest/node-npmtest-ts-loader/node_modules/ts-loader/dist/servicesHost.js":"\"use strict\";\r\nvar constants = require(\"./constants\");\r\nvar path = require(\"path\");\r\nvar makeResolver = require(\"./resolver\");\r\nvar utils = require(\"./utils\");\r\n/**\r\n * Create the TypeScript language service\r\n */\r\nfunction makeServicesHost(scriptRegex, log, loader, instance, appendTsSuffixTo) {\r\n    var compiler = instance.compiler, compilerOptions = instance.compilerOptions, files = instance.files;\r\n    var newLine = compilerOptions.newLine === constants.CarriageReturnLineFeedCode ? constants.CarriageReturnLineFeed :\r\n        compilerOptions.newLine === constants.LineFeedCode ? constants.LineFeed :\r\n            constants.EOL;\r\n    // make a (sync) resolver that follows webpack's rules\r\n    var resolveSync = makeResolver(loader.options);\r\n    var moduleResolutionHost = {\r\n        fileExists: function (fileName) { return utils.readFile(fileName) !== undefined; },\r\n        readFile: function (fileName) { return utils.readFile(fileName); },\r\n    };\r\n    return {\r\n        getProjectVersion: function () { return \"\" + instance.version; },\r\n        getScriptFileNames: function () { return Object.keys(files).filter(function (filePath) { return !!filePath.match(scriptRegex); }); },\r\n        getScriptVersion: function (fileName) {\r\n            fileName = path.normalize(fileName);\r\n            return files[fileName] && files[fileName].version.toString();\r\n        },\r\n        getScriptSnapshot: function (fileName) {\r\n            // This is called any time TypeScript needs a file's text\r\n            // We either load from memory or from disk\r\n            fileName = path.normalize(fileName);\r\n            var file = files[fileName];\r\n            if (!file) {\r\n                var text = utils.readFile(fileName);\r\n                if (!text) {\r\n                    return undefined;\r\n                }\r\n                file = files[fileName] = { version: 0, text: text };\r\n            }\r\n            return compiler.ScriptSnapshot.fromString(file.text);\r\n        },\r\n        /**\r\n         * getDirectories is also required for full import and type reference completions.\r\n         * Without it defined, certain completions will not be provided\r\n         */\r\n        getDirectories: compiler.sys ? compiler.sys.getDirectories : undefined,\r\n        /**\r\n         * For @types expansion, these two functions are needed.\r\n         */\r\n        directoryExists: compiler.sys ? compiler.sys.directoryExists : undefined,\r\n        getCurrentDirectory: function () { return process.cwd(); },\r\n        getCompilationSettings: function () { return compilerOptions; },\r\n        getDefaultLibFileName: function (options) { return compiler.getDefaultLibFilePath(options); },\r\n        getNewLine: function () { return newLine; },\r\n        log: log.log,\r\n        resolveModuleNames: function (moduleNames, containingFile) {\r\n            return resolveModuleNames(resolveSync, moduleResolutionHost, appendTsSuffixTo, scriptRegex, instance, moduleNames, containingFile);\r\n        }\r\n    };\r\n}\r\nfunction resolveModuleNames(resolveSync, moduleResolutionHost, appendTsSuffixTo, scriptRegex, instance, moduleNames, containingFile) {\r\n    var resolvedModules = moduleNames.map(function (moduleName) {\r\n        return resolveModuleName(resolveSync, moduleResolutionHost, appendTsSuffixTo, scriptRegex, instance, moduleName, containingFile);\r\n    });\r\n    populateDependencyGraphs(resolvedModules, instance, containingFile);\r\n    return resolvedModules;\r\n}\r\nfunction resolveModuleName(resolveSync, moduleResolutionHost, appendTsSuffixTo, scriptRegex, instance, moduleName, containingFile) {\r\n    var compiler = instance.compiler, compilerOptions = instance.compilerOptions;\r\n    var resolutionResult;\r\n    try {\r\n        var originalFileName = resolveSync(undefined, path.normalize(path.dirname(containingFile)), moduleName);\r\n        var resolvedFileName = utils.appendTsSuffixIfMatch(appendTsSuffixTo, originalFileName);\r\n        if (resolvedFileName.match(scriptRegex)) {\r\n            resolutionResult = { resolvedFileName: resolvedFileName, originalFileName: originalFileName };\r\n        }\r\n    }\r\n    catch (e) { }\r\n    var tsResolution = compiler.resolveModuleName(moduleName, containingFile, compilerOptions, moduleResolutionHost);\r\n    if (tsResolution.resolvedModule) {\r\n        var resolvedFileName = path.normalize(tsResolution.resolvedModule.resolvedFileName);\r\n        var tsResolutionResult = {\r\n            originalFileName: resolvedFileName,\r\n            resolvedFileName: resolvedFileName,\r\n            isExternalLibraryImport: tsResolution.resolvedModule.isExternalLibraryImport\r\n        };\r\n        if (resolutionResult) {\r\n            if (resolutionResult.resolvedFileName === tsResolutionResult.resolvedFileName) {\r\n                resolutionResult.isExternalLibraryImport = tsResolutionResult.isExternalLibraryImport;\r\n            }\r\n        }\r\n        else {\r\n            resolutionResult = tsResolutionResult;\r\n        }\r\n    }\r\n    return resolutionResult;\r\n}\r\nfunction populateDependencyGraphs(resolvedModules, instance, containingFile) {\r\n    resolvedModules = resolvedModules\r\n        .filter(function (m) { return m !== null && m !== undefined; });\r\n    instance.dependencyGraph[path.normalize(containingFile)] = resolvedModules;\r\n    resolvedModules.forEach(function (resolvedModule) {\r\n        if (!instance.reverseDependencyGraph[resolvedModule.resolvedFileName]) {\r\n            instance.reverseDependencyGraph[resolvedModule.resolvedFileName] = {};\r\n        }\r\n        instance.reverseDependencyGraph[resolvedModule.resolvedFileName][path.normalize(containingFile)] = true;\r\n    });\r\n}\r\nmodule.exports = makeServicesHost;\r\n","/home/travis/build/npmtest/node-npmtest-ts-loader/node_modules/ts-loader/dist/resolver.js":"\"use strict\";\r\nvar node = require(\"enhanced-resolve/lib/node\");\r\nfunction makeResolver(options) {\r\n    return node.create.sync(options.resolve);\r\n}\r\nmodule.exports = makeResolver;\r\n","/home/travis/build/npmtest/node-npmtest-ts-loader/node_modules/ts-loader/dist/watch-run.js":"\"use strict\";\r\nvar path = require(\"path\");\r\nvar utils = require(\"./utils\");\r\nvar constants = require(\"./constants\");\r\n/**\r\n * Make function which will manually update changed files\r\n */\r\nfunction makeWatchRun(instance) {\r\n    var lastTimes = {};\r\n    var startTime = null;\r\n    return function (watching, cb) {\r\n        var watcher = watching.compiler.watchFileSystem.watcher ||\r\n            watching.compiler.watchFileSystem.wfs.watcher;\r\n        if (null === instance.modifiedFiles) {\r\n            instance.modifiedFiles = {};\r\n        }\r\n        startTime = startTime || watching.startTime;\r\n        var times = watcher.getTimes();\r\n        Object.keys(times)\r\n            .filter(function (filePath) {\r\n            return times[filePath] > (lastTimes[filePath] || startTime)\r\n                && !!filePath.match(constants.tsTsxJsJsxRegex);\r\n        })\r\n            .forEach(function (filePath) {\r\n            lastTimes[filePath] = times[filePath];\r\n            filePath = path.normalize(filePath);\r\n            var file = instance.files[filePath];\r\n            if (file) {\r\n                file.text = utils.readFile(filePath) || '';\r\n                file.version++;\r\n                instance.version++;\r\n                instance.modifiedFiles[filePath] = file;\r\n            }\r\n        });\r\n        cb();\r\n    };\r\n}\r\nmodule.exports = makeWatchRun;\r\n"}